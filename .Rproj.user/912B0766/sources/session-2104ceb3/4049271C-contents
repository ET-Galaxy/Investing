---
title: "Univariate forecasts of England hospital admissions"
output:
  pdf_document: default
  html_document:
    df_print: paged
---

```{r setup,include=F}
knitr::opts_chunk$set(warning=F,message=F,echo=F)
library(tis)
library(KFAS)
library(tidyverse)
library(timetk)
library(readxl)
library(pracma)
library(tsbox)
library(xts)
library(httr)
library(zoo)

# Standard update function - edited to allow the targeting of the signal-to-noise ratio
# Signal-to-noise ratio is defined as the variance of the trend component of order 'order' 
# (= 1 for level, = 2 for slope, etc) relative to variance of irregular of series 'index'
# (= 1 for 1st col of dataframe, = 2 for 2nd etc)
updatear1=function(pars, model){
  np = sum(is.na(model$Q)) + sum(is.na(model$H))
  if(any(is.na(model$Q))){
    Q <- as.matrix(model$Q[,,1])
    naQd  <- which(is.na(diag(Q)))
    naQnd <- which(upper.tri(Q[naQd,naQd]) & is.na(Q[naQd,naQd]))
    Q[naQd,naQd][lower.tri(Q[naQd,naQd])] <- 0
    diag(Q)[naQd] <- exp(0.5 * pars[1:length(naQd)])
    Q[naQd,naQd][naQnd] <- pars[length(naQd)+1:length(naQnd)]
    model$Q[naQd,naQd,1] <- crossprod(Q[naQd,naQd])
  }
  if(!identical(model$H,'Omitted') && any(is.na(model$H))){
    H<-as.matrix(model$H[,,1])
    naHd  <- which(is.na(diag(H)))
    naHnd <- which(upper.tri(H[naHd,naHd]) & is.na(H[naHd,naHd]))
    H[naHd,naHd][lower.tri(H[naHd,naHd])] <- 0
    diag(H)[naHd] <-
      exp(0.5 * pars[length(naQd)+length(naQnd)+1:length(naHd)])
    H[naHd,naHd][naHnd] <-
      pars[length(naQd)+length(naQnd)+length(naHd)+1:length(naHnd)]
    model$H[naHd,naHd,1] <- crossprod(H[naHd,naHd])
  }
  T = model$T[,,1]
  model$T[nrow(T),ncol(T),1] = pars[np+1]
  model
}
```

## England

**Includes AR(1) component**

```{r Eng}
#Import data
library(tsgc)
data      <- england

idx<-(index(data)>='2021-07-19')&(index(data)<='2021-09-07')

data1 = data[,1:2]  #$data # 7-day MA of new cases starts rising again from 1 May 2021 => start of 3rd wave %>%
colnames(data1)<-c("cCases", "cAdmit")
data1$newAdmit<-diff(data1$cAdmit)
data_xts<-data1[idx,]
  #tk_xts(select=-date,date_var=date)
```

```{r}
# Compute LDL and lag data appropriately

### must specify the lag order###

data_xts$LDLhosp = log(as.vector(data_xts$newAdmit)/lag(as.vector(data_xts$cAdmit)))

data_ldl <- as.vector(data_xts$LDLhosp) %>% na.omit
```

```{r}

# Create the SSM model
mod <- SSModel(data_ldl ~ SSMtrend(degree = 2, Q = list(matrix(0),matrix(NA)))+
                SSMseasonal(7,Q = matrix(NA), sea.type='dummy')+
                SSMcustom(Z=1,T=1,R=1,Q=matrix(NA)),
                H = matrix(NA))

# Compute number of parameters - this is just the number of NAs in the model Q and H combined.
npar = sum(is.na(mod$Q)) + sum(is.na(mod$H))

# Set the options for the update function for Florida
# We have a signal/noise ratio of 0.005, the signal is the slope and we are 
# targeting the variance of the irregular in cases

fit = fitSSM(mod, c(rep(0,npar),1), updatefn = updatear1)

# Apply the Kalman filter and smoother to the fitted model
out = KFS(fit$model)
```

```{r}
#Create forecasts

### must specify how many days ahead forecast is for###
n.forc = 54 # lose 2 days of data + 7 days ahead

# Create the forecasts
# This gives the forecasts of delta
forcout = predict(out$model,n.ahead = n.forc,interval=c('prediction'),
                  level=0.68,states=c('trend','custom'))

# Create empty dataframe to put forecasts in
forecasts <- matrix(NA,ncol=1,nrow=n.forc) %>%
  as.data.frame()
colnames(forecasts) = c('Admissions')

# Compute forecasts as per (7) in Andrew's Time Series Models for Epidemics paper
# Confidence intervals computed as per Harvey, Kattuman and Thamotheram 2021 NIESR paper
forecasts$Admissions[1] = tail(as.vector(data_xts$cAdmit),1)*exp(forcout[1,1])
forecasts$Admissions[2:n.forc] = tail(as.vector(data_xts$cAdmit),1)*exp(forcout[2:n.forc,1])*cumprod(1+exp(forcout[1:(n.forc-1),1]))

forecasts$Admissions.lwr[1] = tail(as.vector(data_xts$cAdmit),1)*exp(forcout[1,2])
forecasts$Admissions.lwr[2:n.forc] = tail(as.vector(data_xts$cAdmit),1)*exp(forcout[2:n.forc,2])*cumprod(1+exp(forcout[1:(n.forc-1),2])) 

forecasts$Admissions.upr[1] = tail(as.vector(data_xts$cAdmit),1)*exp(forcout[1,3])
forecasts$Admissions.upr[2:n.forc] = tail(as.vector(data_xts$cAdmit),1)*exp(forcout[2:n.forc,3])*cumprod(1+exp(forcout[1:(n.forc-1),3])) 

# Round forecasts to nearest whole number
forecasts = round(forecasts)

admissions_forecasts = cbind(forecasts$Admissions,forecasts$Admissions.lwr,forecasts$Admissions.upr)
colnames(admissions_forecasts) = c('forc','lwr','upr')

startforc = (data_xts %>% index %>% tail(1))+1
finds = seq(startforc,length.out = n.forc,by='day')
```

```{r}
# Re-do with seasonal component

forcout_sea = predict(out$model,n.ahead = n.forc,interval=c('prediction'),
                      level=0.68,states='all')

# Create empty dataframe to put forecasts in
forecasts_sea <- matrix(NA,ncol=1,nrow=max(n.forc)) %>%
  as.data.frame()
colnames(forecasts_sea) = c('Admissions')

# Compute forecasts as per (7) in Andrew's Time Series Models for Epidemics paper
# Confidence intervals computed as per Harvey, Kattuman and Thamotheram 2021 NIESR paper
forecasts_sea$Admissions[1] = tail(as.vector(data_xts$cAdmit),1)*exp(forcout_sea[1,1])
forecasts_sea$Admissions[2:n.forc] = tail(as.vector(data_xts$cAdmit),1)*exp(forcout_sea[2:n.forc,1])*cumprod(1+exp(forcout_sea[1:(n.forc-1),1]))

forecasts_sea$Admissions.lwr[1] = tail(as.vector(data_xts$cAdmit),1)*exp(forcout_sea[1,2])
forecasts_sea$Admissions.lwr[2:n.forc] = tail(as.vector(data_xts$cAdmit),1)*exp(forcout_sea[2:n.forc,2])*cumprod(1+exp(forcout_sea[1:(n.forc-1),2]))
forecasts_sea$Admissions.upr[1] = tail(as.vector(data_xts$cAdmit),1)*exp(forcout_sea[1,3])
forecasts_sea$Admissions.upr[2:n.forc] = tail(as.vector(data_xts$cAdmit),1)*exp(forcout_sea[2:n.forc,3])*cumprod(1+exp(forcout_sea[1:(n.forc-1),3]))

# Round forecasts to nearest whole number
forecasts_sea = cbind(forecasts_sea$Admissions,forecasts_sea$Admissions.lwr,forecasts_sea$Admissions.upr) %>% round()
colnames(forecasts_sea) = c('forc','lwr','upr')
```

```{r}
# add forecasts to plotting dataframe
data_plot = data_xts

fadmits = xts(admissions_forecasts,finds)
data_plot$upr = fadmits #xts(forecasts_sea[,2],finds)
data_plot$sea = xts(forecasts_sea[,1],finds)
#data_plot$lwr = xts(forecasts_sea[,3],finds)#
#data_plot$forc = xts(admissions_forecasts[,1],finds)#
```

```{r}
# Create smoothed admissions
lcadmit = lag(as.vector(data_xts$cAdmit)) %>% na.omit()
smldlh = predict(out$model,states=c('trend','custom')) %>% exp %>% as.vector
smadmit = smldlh*lcadmit[1:length(lcadmit)]
data_plot$smAdmit = smadmit %>% xts(index(data_xts[(2):(length(lcadmit)+1),]))
```

Forecast admissions plotted below. Actual values are in black, the trend forecast is in red, the actual forecast (accounting for day-of-the-week effects) is in light grey and the 1 standard error prediction interval is in blue.

```{r}
#Plot forecast graph

ylim_plot = c(min(as.matrix(cbind(data_plot$newAdmit,data_plot$lwr)),na.rm=T),max(as.matrix(cbind(data_plot$newAdmit,data_plot$upr)),na.rm=T))
invisible(plot(data_plot$newAdmit,main='England - hopsital admissions',
               grid.col=NA,ylim=ylim_plot,col = 'gray',lwd=1))
invisible(lines(data_plot$smAdmit,col='black',lwd=2))
invisible(lines(data_plot$sea,col='lightgray',lwd=1))
invisible(lines(data_plot$forc,col='red',lwd=2))
invisible(lines(data_plot$upr,col='blue',lwd=2))
lines(data_plot$lwr,col='blue',lwd=2)
```

Hospital admissions trend forecasts

```{r}
print(xts(admissions_forecasts,finds))
```

Hospital admissions (actual) forecasts

```{r}
print(xts(forecasts_sea,finds))
```

AR(1) coefficient

```{r}
print(out$model$T["custom1","custom1",1])
```
